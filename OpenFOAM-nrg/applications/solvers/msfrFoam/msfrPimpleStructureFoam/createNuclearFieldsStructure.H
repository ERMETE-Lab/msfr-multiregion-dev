// Redefinition (already declared)
//    rhoCpRef = rhoRef*CpRef;

    #include "readNuclearProperties.H"
    #include "initCrossSections.H"

// Read neutron flux fields
    Info<< "\nReading neutron flux fields (" << nEnergyGroups << ")" << endl;

    PtrList<volScalarField> flux(nEnergyGroups);

    volScalarField fluxTot
    (
        IOobject
        (
            "fluxTot",
            runTime.timeName(),
            mesh,
            IOobject::NO_READ,
            IOobject::AUTO_WRITE
        ),
        mesh,
        dimensionedScalar("", dimless/dimArea/dimTime, 0)
    );

    forAll(flux, i)
    {
        Info<< "    Reading field flux" << i + 1 << endl;
        flux.set
        (
            i,
            new volScalarField
            (
                IOobject
                (
                    "flux" + name(i + 1),
                    runTime.timeName(),
                    mesh,
                    IOobject::MUST_READ,
                    IOobject::AUTO_WRITE
                ),
                mesh
            )
        );

        fluxTot += flux[i]; // update fluxTot with initial flux fields
    }

// Read delayed neutron precursors fields
    Info<< "\nReading delayed neutron precursors fields (" << nPrecGroups << ")" << endl;

    PtrList<volScalarField> prec(nPrecGroups);
    PtrList<volScalarField> precLambda(nPrecGroups);
    PtrList<volScalarField> precBeta(nPrecGroups);


 // Check input data size
    if( precLambda.size() == nPrecGroups && precBeta.size() == nPrecGroups )
    {
        Info<< "    Found " << nPrecGroups << " groups of delayed neutron precursors" << endl;
    }
    else
    {
        FatalError
            << "in " << neutronPrecursorsDict.name() << " , invalid number of delayed neutron precursors constants" << exit(FatalError);
    }

     volScalarField precBetaTot
    (
        IOobject
        (
            "precBetaTot",
            runTime.timeName(),
            mesh,
            IOobject::NO_READ,
            IOobject::NO_WRITE
        ),
        mesh,
        dimensionedScalar("", dimless, 0)
    );


    forAll(prec, i)
    {
        Info<< "    Reading field prec" << i + 1 << endl;
        prec.set
        (
            i,
            new volScalarField
            (
                IOobject
                (
                    "prec" + name(i + 1),
                    runTime.timeName(),
                    mesh,
                    IOobject::MUST_READ,
                    IOobject::AUTO_WRITE
                ),
                mesh
            )
        );


      Info<< "\nReading delayed neutron precursors constants" << endl;

      precLambda.set
        (
            i,
            new volScalarField
            (
                IOobject
                (
                    "precLambda" + name(i + 1),
                    runTime.timeName(),
                    mesh,
                    IOobject::MUST_READ,
                    IOobject::NO_WRITE
                ),
                mesh
            )
        );

	precBeta.set
        (
            i,
            new volScalarField
            (
                IOobject
                (
                    "precBeta" + name(i + 1),
                    runTime.timeName(),
                    mesh,
                    IOobject::MUST_READ,
                    IOobject::NO_WRITE
                ),
                mesh
            )
        );

   precBetaTot += precBeta[i];

   }

// Read decay heat precursors fields
    Info<< "\nReading decay heat precursors fields (" << nDecGroups << ")" << endl;

    PtrList<volScalarField> dec(nDecGroups);
    PtrList<volScalarField> decLambda(nDecGroups);
    PtrList<volScalarField> decBeta(nDecGroups);

//Check input data size
  if( decLambda.size() == nDecGroups && decBeta.size() == nDecGroups )
    {
        Info<< "    Found " << nDecGroups << " groups of decay heat precursors" << endl;
    }
    else
    {
        FatalError
            << "in " << decayHeatPrecursorsDict.name() << " , invalid number of decay heat precursors constants" << exit(FatalError);
    }




         volScalarField decBetaTot
    (
        IOobject
        (
            "decBetaTot",
            runTime.timeName(),
            mesh,
            IOobject::NO_READ,
            IOobject::NO_WRITE
        ),
        mesh,
        dimensionedScalar("", dimless, 0)
    );

    forAll(dec, i)
    {
        Info<< "    Reading field dec" << i + 1 << endl;
        dec.set
        (
            i,
            new volScalarField
            (
                IOobject
                (
                    "dec" + name(i + 1),
                    runTime.timeName(),
                    mesh,
                    IOobject::MUST_READ,
                    IOobject::AUTO_WRITE
                ),
                mesh
            )
        );

       decLambda.set
        (
            i,
            new volScalarField
            (
                IOobject
                (
                    "decLambda" + name(i + 1),
                    runTime.timeName(),
                    mesh,
                    IOobject::MUST_READ,
                    IOobject::NO_WRITE
                ),
                mesh
            )
        );

        decBeta.set
        (
            i,
            new volScalarField
            (
                IOobject
                (
                    "decBeta" + name(i + 1),
                    runTime.timeName(),
                    mesh,
                    IOobject::MUST_READ,
                    IOobject::NO_WRITE
                ),
                mesh
            )
        );
        decBetaTot += decBeta[i];
}

// Read fission products fields (if needed)
    PtrList<volScalarField> fp;
    PtrList<volScalarField> fpd;

    if (fpTransport)
    {
        Info<< "\nReading fission products fields (" << nFPSpecies << ")" << endl;

        fp.setSize(nFPSpecies);
        fpd.setSize(nFPSpecies);

        forAll(fp, i)
        {
            Info<< "    Reading field fp" << i + 1 << endl;
            fp.set
            (
                i,
                new volScalarField
                (
                    IOobject
                    (
                        "fp" + name(i + 1),
                        runTime.timeName(),
                        mesh,
                        IOobject::MUST_READ,
                        IOobject::AUTO_WRITE
                    ),
                    mesh
                )
            );

            fpd.set
            (
                i,
                new volScalarField
                (
                    IOobject
                    (
                        "fpd" + name(i + 1),
                        runTime.timeName(),
                        mesh,
                        IOobject::MUST_READ,
                        IOobject::AUTO_WRITE
                    ),
                    mesh
                )
            );
        }
    }

// Create neutron transport fields
    Info<< "\nCreating neutron transport constants fields" << endl;

    // Temperature-dependent properties are declared as fields, which populate
    // corresponding pointer lists
    // Dummy initialisation to reference values
    PtrList<volScalarField> D(nEnergyGroups);
    PtrList<volScalarField> Sa(nEnergyGroups);
    PtrList<volScalarField> Sf(nEnergyGroups);
    PtrList<volScalarField> Ss(nEnergyGroups*nEnergyGroups);

// For each property, reference values and temp. coefficients are now 
// declared as fields in order to assign different values for different regions
// dictionary into a List<scalar>, and declare a PtrList<dimensionedSca$    

    // Net production operators, to be used later
    PtrList<volScalarField> M(nEnergyGroups);

    forAll(D, i)
    {
        word iName = name(i + 1);

        D.set
        (
            i,
            new volScalarField
            (
                IOobject
                (
                    "D" + iName,
                    runTime.timeName(),
                    mesh,
                    IOobject::NO_READ,
                    IOobject::NO_WRITE
                ),
                //mesh
                D_ref[i]
            )
        );

        Sa.set
        (
            i,
            new volScalarField
            (
                IOobject
                (
                    "Sa" + iName,
                    runTime.timeName(),
                    mesh,
                    IOobject::NO_READ,
                    IOobject::NO_WRITE
                ),
             //   mesh
                Sa_ref[i]
            )
        );


        Sf.set
        (
            i,
            new volScalarField
            (
                IOobject
                (
                    "Sf" + iName,
                    runTime.timeName(),
                    mesh,
                    IOobject::NO_READ,
                    IOobject::NO_WRITE
                ),
               // mesh
               Sf_ref[i]
            )
        );

        forAll(D, j)
        {
            label ijInd = nEnergyGroups*i + j;
            word ijName = name(i +1) + name(j +1);

            Ss.set
            (
                ijInd,
                new volScalarField
                (
                    IOobject
                    (
                        "Ss" + ijName,
                        runTime.timeName(),
                        mesh,
                        IOobject::NO_READ,
                        IOobject::NO_WRITE
                    ),
                 //   mesh
                    Ss_ref[ijInd]
                )
            );
        }

        M.set
        (
            i,
            new volScalarField
            (
                IOobject
                (
                    "M" + iName,
                    runTime.timeName(),
                    mesh,
                    IOobject::NO_READ,
                    IOobject::NO_WRITE
                ),
              //  mesh
               0*Nu[i]*Sf_ref[i]
            )
        );
    }

    volScalarField diffCoeffAlbedo
    (
        IOobject
        (
            "diffCoeffAlbedo",
            runTime.timeName(),
            mesh
        ),
        0*D[0]
    );

// Create other fields

    const volScalarField unitField // unit dimless field to help declaration of other fields
    (
        IOobject
        (
            "unitField",
            runTime.timeName(),
            mesh,
            IOobject::NO_READ,
            IOobject::NO_WRITE
        ),
        mesh,
        dimensionedScalar("", dimless, 1)
    );

    const volScalarField zeroField = 0*unitField; // zero dimless field

    volScalarField Rf // fission rate
    (
        IOobject
        (
            "Rf",
            runTime.timeName(),
            mesh,
            IOobject::READ_IF_PRESENT,
            IOobject::AUTO_WRITE
        ),
        mesh,
        dimensionedScalar("", dimless/dimVolume/dimTime, 0)
    );

    volScalarField q // heat source density
    (
        IOobject
        (
            "q",
            runTime.timeName(),
            mesh,
            IOobject::READ_IF_PRESENT,
            IOobject::AUTO_WRITE
        ),
        mesh,
        dimensionedScalar("", dimPower/dimVolume, 0)
    );

    volScalarField qPrompt // prompt heat source density
    (
        IOobject
        (
            "qPrompt",
            runTime.timeName(),
            mesh,
            IOobject::READ_IF_PRESENT,
            IOobject::AUTO_WRITE
        ),
        mesh,
        dimensionedScalar("", dimPower/dimVolume, 0)
    );

    volScalarField qDecay // decay heat source density
    (
        IOobject
        (
            "qDecay",
            runTime.timeName(),
            mesh,
            IOobject::READ_IF_PRESENT,
            IOobject::AUTO_WRITE
        ),
        mesh,
        dimensionedScalar("", dimPower/dimVolume, 0)
    );

    volScalarField Q // integrated heat source (uniform field)
    (
        IOobject
        (
            "Q",
            runTime.timeName(),
            mesh,
            IOobject::READ_IF_PRESENT,
            IOobject::NO_WRITE
        ),
        mesh,
        dimensionedScalar("", dimPower, 0)
    );

    volScalarField Qprompt = Q;
    volScalarField Qdecay = Q;

 //   volScalarField qPrompt = q;
 //   volScalarField qDecay = q;

    volScalarField NuRf = zeroField*dimensionedScalar("", dimless/dimVolume/dimTime, 0);
    volScalarField EfRf = zeroField*dimensionedScalar("", dimEnergy/dimVolume/dimTime, 0);

    PtrList<volScalarField> neutronSource(nEnergyGroups);
    forAll(neutronSource, i)
    {
        neutronSource.set
        (
            i,
            new volScalarField
            (
                IOobject
                (
                    "neutronSource" + name(i + 1),
                    runTime.timeName(),
                    mesh,
                    IOobject::NO_READ,
                    IOobject::NO_WRITE
                ),
                mesh,
                dimensionedScalar("", dimless/dimVolume/dimTime, 0)
            )
        );
    }

    volScalarField rhoNorm
    (
        IOobject
        (
            "rhoNorm",
            runTime.timeName(),
            mesh,
            IOobject::NO_READ,
            IOobject::NO_WRITE
        ),
        mesh,
        dimensionedScalar("", dimless, 0)
    );

    volScalarField logT = zeroField;

// Read values related to reactor control
    Info<< "\nReading reactor control parameters" << endl;

    Switch tempCoupling(runTime.controlDict().lookup("tempCoupling"));

    dimensionedScalar KeffInit("KeffInit", dimless, runTime.controlDict().lookupOrDefault<scalar>("Keff", 1));


    dimensionedScalar Qnominal("Qnominal", dimPower, runTime.controlDict().lookup("nominalPower"));

    volScalarField Keff
    (
        IOobject
        (
            "Keff",
            runTime.timeName(),
            mesh,
            IOobject::READ_IF_PRESENT,
            IOobject::AUTO_WRITE
        ),
        mesh,
        KeffInit
    );

    volScalarField reactivity
    (
        IOobject
        (
            "reactivity",
            runTime.timeName(),
            mesh
        ),
        (Keff - 1)/Keff
    );

    Info<< "    Nominal reactor power  : " << Qnominal.value()/1E+06 << " MW" << endl;
    Info<< "    Keff                   : " << max(Keff).value() << endl;
    Info<< "    Reactivity             : " << max(reactivity).value()*1e5 << " pcm" << endl;

// Initialise fields
    #include "updateCrossSections.H"
    #include "updateFissionRate.H"
    #include "updatePowerSource.H"
    #include "updateNeutronSource.H"
